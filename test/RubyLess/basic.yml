empty:
  src: ""
  tem: null

numbers:
  src: "id > 45 and (3 > -id or 3+3)"
  tem: "((var1.zip>45) and ((3>-var1.zip) or (3+3)))"

global_method:
  src: "now.strftime('%Y')"
  tem: "Time.now.strftime(\"%Y\")"

dynamic_string:
  src: "now.strftime(\"#{name}\")"
  tem: "Time.now.strftime(\"#{var1.name}\")"

dynamic_string_again:
  src: "now.strftime(\"#{name}\")"
  tem: "Time.now.strftime(\"#{var1.name}\")"

symbol:
  src: ":foobar"
  sxp: 's(:lit, :foobar)'

hash_access:
  src: "dictionary[:key]"
  tem: "get_dict[:key]"

rewrite_variables:
  src: "!prev.ancestor?(main) && !node.ancestor?(main)"
  tem: "(not previous.ancestor?(@node) and not var1.ancestor?(@node))"

method_can_return_nil:
  src: "spouse.name"
  tem: "(var1.spouse ? var1.spouse.name : nil)"

method_on_method_can_return_nil:
  src: "spouse.name == 'yo'"
  tem: "(var1.spouse ? (var1.spouse.name==\"yo\") : nil)"
  res: ""

nil_greater_then:
  src: "spouse.id > 1"
  tem: "(var1.spouse ? (var1.spouse.zip>1) : nil)"

nil_ternary_op:
  src: "spouse ? 'foo' : 'bar'"
  tem: "var1.spouse ? \"foo\" : \"bar\""
  res: 'bar'

nested_ternary_op:
  src: "spouse.name == 'Adam' ? 'man' : 'not a man'"
  tem: "(var1.spouse ? (var1.spouse.name==\"Adam\") : nil) ? \"man\" : \"not a man\""
  res: "not a man"

method_on_method:
  src: "project.name.to_s"
  tem: "var1.project.name.to_s"
  res: 'project'

comp_ternary_op:
  src: "1 > 2 ? 'foo' : 'bar'"
  tem: "(1>2) ? \"foo\" : \"bar\""
  res: "bar"

method_ternary_op:
  src: "id > 2 ? 'foo' : 'bar'"
  tem: "(var1.zip>2) ? \"foo\" : \"bar\""
  res: "foo"

method_argument_can_be_nil:
  src: "vowel_count(spouse.name)"
  tem: "(var1.spouse ? vowel_count(var1.spouse.name) : nil)"

multi_arg_method_argument_can_be_nil:
  src: "log_info(spouse, 'foobar')"
  tem: "(var1.spouse ? log_info(var1.spouse, \"foobar\") : nil)"

multi_arg_method_arguments_can_be_nil:
  src: "log_info(husband, spouse.name)"
  tem: "((var1.husband && var1.spouse) ? log_info(var1.husband, var1.spouse.name) : nil)"

multi_arg_method_arguments_can_be_nil_same_condition:
  src: "log_info(spouse, spouse.name)"
  tem: "(var1.spouse ? log_info(var1.spouse, var1.spouse.name) : nil)"

literal_argument_for_method:
  src: "vowel_count('ruby')"
  res: "2"

safe_method_defined_as_symbol:
  src: "foo"
  tem: "contextual_foo"

optional_arguments:
  src: "width(:mode => 'pv')"
  tem: "var1.width({:mode => \"pv\"})"
  res: "mode: pv, type: none"

optional_arguments_string:
  src: "width('nice' => 1 == 1)"
  tem: "var1.width({\"nice\" => (1==1)})"
  res: "nice!"